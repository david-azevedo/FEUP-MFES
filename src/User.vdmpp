class User
types
values
	
instance variables

	public name: Types`String;
	private friends: Types`UserSet;
	private routes: Types`RouteToWorkouts;
	private top: Types`TopWorkout;
	private currentWorkout: [Workout];
	private global : [Global];
	private statistics: Statistics;
	private completedChallenges: Types`ChallengeSet;
	-- Challenges which the user is owner of
	private owner: Types`ChallengeSet;
	-- Challenges which the user is participating
	private participation: Types`ChallengeSet;
	private rank: Types`Rank;
	inv completedChallenges subset (owner union participation);
	
operations


	--User's constructor
	public User: Types`String * Global ==> User
	User(n, g) == (
		currentWorkout := nil;
		global:= g;
		friends := {};
		top := {|->};
		routes := {|->};
		name := n;
		statistics := new Statistics();
		completedChallenges := {};
		owner := {};
		participation := {};
		rank := <Lazy>;
		return self
	)
	post name = n;
	
	public resetStatistics: () ==> ()
	resetStatistics() == (
		statistics.reset();
	);
	
	public createDistanceChallenge: Types`String * nat ==> ()
	createDistanceChallenge(n, d) == (
		owner := owner union {new DistanceChallenge(n, self, d)};
	);
	
	-- TODO
	public createRouteChallenge: Types`String * Types`Route ==> ()
	createRouteChallenge(n, r) == (
		owner := owner union {new RouteChallenge(n, self, r)};
	);
	
	--Add a friend to the user by string
	public addFriend: Types`String ==> ()
	addFriend(n) ==
	(
		dcl friend : [User] := global.getUser(n);
		if friend <> nil then
			(
			addFriend(friend);
			friend.addFriend(self);
			);
	)
	post card friends - card friends~ <= 1 and not self in set friends;
	
	
	--Add a new friend
	public addFriend: [User] ==> ()
	addFriend(friend) ==
	(
		friends := friends union {friend};
	)
	pre friend <> nil and self <> friend
	post card friends = card friends~ + 1 and not self in set friends;
	
	
	--Removes a friend from the user by string
	public removeFriend: Types`String ==> ()
	removeFriend(n) ==
	(		
		for all f in set friends do
			if f.name = n then
			(
				removeFriend(f);
				f.removeFriend(self);	
			);
	)
	post friends subset friends~ and card friends = card friends~ - 1;
	 
	 
	--Removes a friend
	public removeFriend: [User] ==> ()
	removeFriend(friend) ==
	(
		friends := friends \ {friend};
	)
	pre friend <> nil
	post card friends = card friends~ - 1 and friends subset friends~;	
	
	
	--Lists all the friends.
	public listFriends: () ==> Types`StringSeq
	listFriends() == (
		dcl result: Types`StringSeq := [];
		for all friend in set friends do 
			result := result ^ [friend.name];
		return result;
	);
	
	--Starts a workout given a name and the current time in seconds
	public startWorkout: Types`String * nat ==> ()
	startWorkout( routeName, startTime ) ==
	(
		dcl time : Types`Timestamp := Math`secondsToTime(startTime);
		dcl route : [Types`Route] := nil;
		
		for all r in set dom routes do
			if r.name = routeName then
				route := r;
		
		if route <> nil then
			currentWorkout := new WorkoutExisting(time, route)
		else
			(
			route := mk_Types`Route(routeName, []);
			currentWorkout := new WorkoutNew(time, route);
			);
	)
	post ((isofclass(WorkoutExisting, currentWorkout)
					and
					exists1 route in set dom routes & route.name =  routeName)
			 	or
				isofclass(WorkoutNew, currentWorkout));


	--Cancels the current workout
	public cancelCurrentWorkout: () ==> ()
	cancelCurrentWorkout() == 
	(
		currentWorkout := nil;
	)
	post currentWorkout = nil;
	
	
	--Updates GPS coords to update workout state
	public updateByGPS: Types`Point ==> ()
	updateByGPS(point) ==
	(
		currentWorkout.newGPSPosition(point)
	)
	pre currentWorkout <> nil
	post currentWorkout <> nil;
	
	
	--Update Top
	private updateTop: Workout ==> ()
	updateTop (workout) ==
	(
		dcl pair : Types`TopWorkout := 
			{workout.getRoute()} <: top;
		
		if pair <> {|->} then
			(if exists1 t in set (rng pair) & 
					Math`timeToSeconds(t.calculateTime()) > 
					Math`timeToSeconds(workout.calculateTime()) then
				top := top ++ {workout.getRoute() |-> workout};)
		else
			top := top ++ {workout.getRoute() |-> workout};
	)
	post card dom top >= card dom top~;
	
	
	--Stores current workout
	private storeCurrentWorkout: () ==> ()
	storeCurrentWorkout() ==
	(
		dcl r1 : Types`Route := currentWorkout.getRoute();
		dcl pair : Types`RouteToWorkouts :=
			{currentWorkout.getRoute()} <: routes;
		
		updateTop(currentWorkout);
		
		if pair <> {|->} then
			for all e in set rng pair do
			routes := routes ++ 
								{r1 |-> e ^ [currentWorkout]}	
		else
			routes := routes ++ {r1 |-> [currentWorkout]};
	)
	post card dom routes >= card dom routes~;
	
	
	--Get Routes Performed
	public getRoutesPerformed: () ==> Types`RouteToNat
	getRoutesPerformed() ==
	(
		dcl res : Types`RouteToNat := {|->};
		
		for all route in set dom routes do
			for all workouts in set rng ({route} <: routes) do
				res := res ++ {route |-> len workouts};		
		
		return res;	
	)
	post card dom RESULT = card dom routes;
	
	
	--Get Top
	public getTop: () ==> Types`RouteToNat
	getTop() ==
	(
		dcl res : Types`RouteToNat := {|->};
		
		for all route in set dom top do
			for all workout in set rng ({route} <: top) do
				res := res ++ {route |-> Math`timeToSeconds(workout.calculateTime())};		
		
		return res;	
	)
	post card dom RESULT = card dom top;
	
	--List Routes
	public listRoutes: () ==> Types`StringSeq
	listRoutes() ==
	(
		dcl res: Types`StringSeq := [];
		
		for all e in set dom routes do
			res:= res ^ [e.name];
		
		return res;
	)
	post routes = routes~;
	
	
	--Finishes the current workout
	public finishCurrentWorkout: nat ==> ()
	finishCurrentWorkout(time) ==
	(
		currentWorkout.finish(Math`secondsToTime(time));
		if currentWorkout.isFinished() then
			storeCurrentWorkout();
		
		currentWorkout := nil;
	)
	pre currentWorkout <> nil
	post currentWorkout = nil;
	
functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end User