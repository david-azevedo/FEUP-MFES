class User
types
values
	
instance variables

	public name: Types`String;
	private friends: Types`UserSet;
	private routes: Types`RouteToWorkouts;
	private currentWorkout: [Workout];
	private global : [Global];
	private statistics: Statistics;
	private completedChallenges: Types`ChallengeSet;
	-- Challenges which the user is owner of
	private owner: Types`ChallengeSet;
	-- Challenges which the user is participating
	private participation: Types`ChallengeSet;
	private rank: Types`Rank;
	inv completedChallenges subset (owner union participation);
	
operations


	--User's constructor
	public User: Types`String * Global ==> User
	User(n, g) == (
		currentWorkout := nil;
		global:= g;
		friends := {};
		routes := {|->};
		name := n;
		statistics := new Statistics();
		completedChallenges := {};
		owner := {};
		participation := {};
		rank := <Lazy>;
		return self
	)
	post name = n;
	
	public resetStatistics: () ==> ()
	resetStatistics() == (
		statistics.reset();
	);
	
	public createDistanceChallenge: Types`String * nat ==> ()
	createDistanceChallenge(n, d) == (
		owner := owner union {new DistanceChallenge(n, self, d)};
	);
	
	-- TODO
	public createRouteChallenge: Types`String * Types`Route ==> ()
	createRouteChallenge(n, r) == (
		owner := owner union {new RouteChallenge(n, self, r)};
	);
	
	--Add a friend to the user by string
	public addFriend: Types`String ==> ()
	addFriend(n) ==
	(
		dcl friend : [User] := global.getUser(n);
		if friend <> nil then
			(
			addFriend(friend);
			friend.addFriend(self);
			);
	)
	post card friends - card friends~ <= 1 and not self in set friends;
	
	
	--Add a new friend
	public addFriend: [User] ==> ()
	addFriend(friend) ==
	(
		friends := friends union {friend};
	)
	pre friend <> nil and self <> friend
	post card friends = card friends~ + 1 and not self in set friends;
	
	
	--Removes a friend from the user by string
	public removeFriend: Types`String ==> ()
	removeFriend(n) ==
	(		
		for all f in set friends do
			if f.name = n then
			(
				removeFriend(f);
				f.removeFriend(self);	
			);
	)
	post friends subset friends~ and card friends = card friends~ - 1;
	 
	 
	--Removes a friend
	public removeFriend: [User] ==> ()
	removeFriend(friend) ==
	(
		friends := friends \ {friend};
	)
	pre friend <> nil
	post card friends = card friends~ - 1 and friends subset friends~;	
	
	
	--Lists all the friends.
	public listFriends: () ==> Types`StringSeq
	listFriends() == (
		dcl result: Types`StringSeq := [];
		for all friend in set friends do 
			result := result ^ [friend.name];
		return result;
	);
	
	--Starts a workout given a name and the current time in seconds
	public startWorkout: Types`String * nat ==> ()
	startWorkout( routeName, startTime ) ==
	(
		dcl time : Types`Timestamp := Math`secondsToTime(startTime);
		dcl route : [Types`Route] := nil;
		
		for all r in set dom routes do
			if r.name = routeName then
				route := r;
		
		if route <> nil then
			currentWorkout := new WorkoutExisting(time, route)
		else
			(
			route := mk_Types`Route(routeName, []);
			currentWorkout := new WorkoutNew(time, route);
			);
	)
	post	(isofbaseclass(WorkoutExisting, currentWorkout) 
			 	or
				isofbaseclass(WorkoutNew, currentWorkout))
				and currentWorkout <> nil;


	--Cancels the current workout
	public cancelCurrentWorkout: () ==> ()
	cancelCurrentWorkout() == 
	(
		currentWorkout := nil;
	)
	post currentWorkout = nil;
	
	
	--Updates GPS coords to update workout state
	public updateByGPS: Types`Point ==> ()
	updateByGPS(point) ==
	(
		currentWorkout.newGPSPosition(point)
	)
	pre currentWorkout <> nil
	post currentWorkout <> nil;
	
	
	--Finishes the current workout
	public finishCurrentWorkout: nat ==> ()
	finishCurrentWorkout(time) ==
		currentWorkout.finish(Math`secondsToTime(time))
	pre currentWorkout <> nil
	post currentWorkout <> nil;
	
functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end User